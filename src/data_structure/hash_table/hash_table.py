# ハッシュテーブル
# Mを正の整数、xを0以上M未満の整数として3つのクエリを高速に処理することを考える
# xをデータ構造に挿入、xをデータ構造から削除、xがデータ構造に含まれるか判定
# いずれもO(1)の計算量で処理できる
# 整数とは限らない一般的なデータ集合Sの各要素xに対し、
# 0 <= h(x) < Mを満たす整数h(x)に対応させることを考える
# h(x):ハッシュ関数, x:キー, ハッシュ関数の値h(x):ハッシュ値

# キーをハッシュ値にする際、異なるキーでも同じハッシュ値を生成してしまう
# 衝突が発生することがある。それを回避する方法として、各ハッシュ値ごとに
# 連結リストを構築する方法がある。
# ハッシュ値が等しいもの同士で連結リストを構築する

# ハッシュテーブルの計算量
# 「任意のキーに対してハッシュ値が特定の値をとる確率が1/Mであり、
# 任意の2つのキーに対して、それらの類似性とは関係なくハッシュ値が衝突する
# 確率が1/Mである」という単純一様ハッシュの仮定を満たすとき、
# ハッシュテーブルの各要素にアクセスする計算量は平均的にO(1+N/M)となる
# α=N/Mを負荷率と呼ぶ。α=1/2程度とすれば十分O(1)の計算量が達成できるとされている

# 衝突を回避するための連結リスト
class LinkedList:
    def __init__(self, value):
        self.value = value
        self.next = None

# ハッシュテーブルクラス
class HashTable:
    def __init__(self):
        self.table = [None] * 1000